group_by(year) |>
summaraize(prop_x = mean(str_detect(name, "x"))) |>
ggplot(aes(x = year, y = prop_x)) +
geom_line()
babynames |>
group_by(year) |>
summaraize(prop_x = mean(str_detect(name, "x"))) |>
ggplot(aes(x = year, y = prop_x)) +
geom_line()
babynames |>
group_by(year) |>
summarize(prop_x = mean(str_detect(name, "x"))) |>
ggplot(aes(x = year, y = prop_x)) +
geom_line()
str_count(x, "p")
x <- c("apple", "banana", "pear", "orange", "grape")
str_count(x, "p")
str_count("abababa", "aba")
str_view("abababa", "aba")
babynames |>
count(name)
babynames |>
count(name) |>
mutate( vowels = str_count(name, "[aeiou]"),
consonants = str_count(name, "[^aeiou]"))
babynames |>
count(name) |>
mutate( vowels = str_count(name, "[aeiou]", ignore_case= TRUE),
consonants = str_count(name, "[^aeiou]"))
babynames |>
count(name) |>
mutate( vowels = str_count(name, regex("[aeiou]", ignore_case= TRUE)),
consonants = str_count(name, "[^aeiou]"))
consonants = str_count(name, regex("[^aeiou]", ignore_case= TRUE))
babynames |>
count(name) |>
mutate( vowels = str_count(name, regex("[aeiou]", ignore_case= TRUE)),
consonants = str_count(name, regex("[^aeiou]", ignore_case= TRUE)))
babynames |>
count(name) |>
mutate( vowels = str_count(name, regex("[aeiou]", ignore_case= TRUE)),
consonants = str_count(name, regex("[^aeiou]", ignore_case= TRUE))
name = str_to_lower(name))
consonants = str_count(name, regex("[^aeiou]", ignore_case= TRUE)
babynames |>
babynames |>
count(name) |>
mutate( vowels = str_count(name, regex("[aeiou]", ignore_case= TRUE)),
consonants = str_count(name, regex("[^aeiou]", ignore_case= TRUE)
name = str_to_lower(name)))
babynames |>
count(name) |>
mutate( vowels = str_count(name, regex("[aeiou]", ignore_case= TRUE)),
consonants = str_count(name, regex("[^aeiou]", ignore_case= TRUE)),
name = str_to_lower(name))
x <- c("apple", "banana", "pear", "orange", "grape")
str_replace_all(x, "[aeiou]", "-")
x <- c("apple", "banana", "pear", "orange", "grape")
str_remove_all(x, "[aeiou]")
str_remove(x, "[aeiou]")
df <- tribble(
~str,
"<Sheryl>-F_34",
"<Kisha>-F_45",
"<Brandon>-N_33",
"<Sharon>-F_38",
"<Penny>-F_58",
"<Justin>-M_41",
"<Patricia>-F_84",
)
View(df)
df |>
separate_wider_regex(
str,
patterns = c(
"<",
name = "[A-Za-z]+",
">-",
gender = ".",
"_",
age = "[0-9]+"
)
)
library(tidyr)
df |>
separate_wider_regex(
str,
patterns = c(
"<",
name = "[A-Za-z]+",
">-",
gender = ".",
"_",
age = "[0-9]+"
)
)
babynames |>
count(name) |>
mutate(vowels = str_count(name, "[aeiou]")) |>
arrange(desc(vowels)) |>
head(10)
# What name has the highest proportion of vowels?
babynames |>
count(name) |>
mutate(vowels = str_count(name, "[aeiou]"),
consonants = str_count(name, "[^aeiou]"),
prop_vowels = vowels / (vowels + consonants)) |>
arrange(desc(prop_vowels)) |>
head(10)
# Replace all forward slashes in "a/b/c/d/e" with backslashes. What happens if you attempt to undo the transformation by replacing all backslashes with forward slashes?
str_replace_all("a/b/c/d/e", "/", "\")
# Replace all forward slashes in "a/b/c/d/e" with backslashes. What happens if you attempt to undo the transformation by replacing all backslashes with forward slashes?
str_replace_all("a/b/c/d/e", "/", "\\")
# Replace all forward slashes in "a/b/c/d/e" with backslashes. What happens if you attempt to undo the transformation by replacing all backslashes with forward slashes?
str_replace_all("a/b/c/d/e", "\", "b")
# Replace all forward slashes in "a/b/c/d/e" with backslashes. What happens if you attempt to undo the transformation by replacing all backslashes with forward slashes?
str_replace_all("a/b/c/d/e", "a", "b")
# Replace all forward slashes in "a/b/c/d/e" with backslashes. What happens if you attempt to undo the transformation by replacing all backslashes with forward slashes?
str_replace_all("a/b/c/d/e", "/", "\")
str_replace_all("a/b/c/d/e", "/", "\")
str_replace_all("a/b/c/d/e", "/", "\")
# Replace all forward slashes in "a/b/c/d/e" with backslashes. What happens if you attempt to undo the transformation by replacing all backslashes with forward slashes?
str_replace_all("a/b/c/d/e", "/", "?")
str_replace_all("a/b/c/d/e", "/", "\")
str_replace_all("a/b/c/d/e", "/", "\")
str_replace_all("a/b/c/d/e", "/", ''\'')
str_replace_all("a/b/c/d/e", "/", "\\")
^\(?([2-9]\d{2})\)?[-.]?([2-9]\d{2})[-.]?(\d{4})$
^\(?([2-9]\d{2})\)?[-.]?([2-9]\d{2})[-.]?(\d{4})$
dot <- "\\."
str_view(d0t)
str_view(dot)
str_view(c("abc","a.c","bef"),"a\\.c")
str_view(c("abc","a.c","bef"),a\\.c)
str_view(c("abc","a.c","bef"),abc)
str_view(c("abc","a.c","bef"),"a//.c")
str_view(c("abc","a.c","bef"),"a//.c")
str_view(c("abc","a.c","bef"),"a\\.c")
# If \ is used as an escape character in regular expressions, how do you match a literal \? Well, you need to escape it, creating the regular expression \\. To create that regular expression, you need to use a string, which also needs to escape \. That means to match a literal \ you need to write "\\\\" — you need four backslashes to match one!
x <- "a\\b"
str_view(x)
str_view(x,"\\\\")
# Alternatively, you might find it easier to use the raw strings you learned about in Section 14.2.2). That lets you avoid one layer of escaping:
str_view(x, r"{\\}")
# If you’re trying to match a literal ., $, |, *, +, ?, {, }, (, ), there’s an alternative to using a backslash escape: you can use a character class: [.], [$], [|], ... all match the literal values.
str_view(c("a.b","a$b","a|b"),"[.]")
# If you’re trying to match a literal ., $, |, *, +, ?, {, }, (, ), there’s an alternative to using a backslash escape: you can use a character class: [.], [$], [|], ... all match the literal values.
str_view(c("a.b","a$b","a|b"),"[|]")
str_view(c("a.b","a$b","a|b"),"[.]")
str_view(c("abc","a.c","bef"),"a\\.c")
# By default, regular expressions will match any part of a string. If you want to match at the start or end you need to anchor the regular expression using ^ to match the start or $ to match the end:
str_view(fruit, "^a"))
# By default, regular expressions will match any part of a string. If you want to match at the start or end you need to anchor the regular expression using ^ to match the start or $ to match the end:
str_view(fruit, "^a")
str_view(fruit, "e$")
str_view(fruit, "^e$")
str_view(fruit, "^a$")
str_view(fruit, "^a$")
str_view(fruit, "a$")
# To force a regular expression to match only the full string, anchor it with both ^ and $
str_view(fruit, "^apple$")
str_view(fruit, "apple")
# You can also match the boundary between words (i.e. the start or end of a word) with \b. This can be particularly useful when using RStudio’s find and replace tool. For example, if to find all uses of sum(), you can search for \bsum\b to avoid matching summarize, summary, rowsum and so on:
x <- c("summary(x)", "summarize(df)","rowsum(x)", "sum(x)")
str_view(x,"sum")
str_view(x,"\\bsum\\b")
str_view(x,"\bsum\b")
str_view(x,"\\bsum\\b")
# When used alone, anchors will produce a zero-width match:
str_view("abc", c("$", "^","\\b", "--"))
# When used alone, anchors will produce a zero-width match:
str_view("abc", c("$", "^","\\b")
str_view("abc", c("$", "^","\\b")
# When used alone, anchors will produce a zero-width match:
str_view("abc", c("$", "^","\\b"))
str_view("abc", c("$", "^","\\b"))
str_replace_all("abc",c("$","^","//b", "--"))
# This helps you understand what happens when you replace a standalone anchor:
str_replace_all("abc",c("$","^","//b"),"--")
# This helps you understand what happens when you replace a standalone anchor:
str_replace_all("abc",c("$","^","\\b"),"--")
# - defines a range, e.g., [a-z] matches any lower case letter and [0-9] matches any number.
# \ escapes special characters, so [\^\-\]] matches ^, -, or ].
x <- "abcd ABCD 12345 -!@#%."
str_view(x, "[abc]+")
str_view(x, "[a-z]+")
str_view(x, "[0-9]+")
str_view(x,"[^a-z0-9]+")
str_view("a-b-c", "[a-c]")
str_view("a-b-c","[a\\-c")
str_view("a-b-c","[a\\-c"])
str_view("a-b-c","[a\\-c]")
x <- "abcd ABCD 12345 -!@#%."
str_view(x, "\\d+")
str_view(x, "\d+")
str_view(x, "\\d+")
str_view(x, "\\D+")
str_view(x, "\\s+")
str_view(x, "\\S+")
str_view(x, "\\w+")
str_view(x, "\\W+")
# The first way to use a capturing group is to refer back to it within a match with back reference: \1 refers to the match contained in the first parenthesis, \2 in the second parenthesis, and so on. For example, the following pattern finds all fruits that have a repeated pair of letters:
str_view(fruit, "(..)\\1")
# The first way to use a capturing group is to refer back to it within a match with back reference: \1 refers to the match contained in the first parenthesis, \2 in the second parenthesis, and so on. For example, the following pattern finds all fruits that have a repeated pair of letters:
str_view(fruit, "(...)\\1")
# The first way to use a capturing group is to refer back to it within a match with back reference: \1 refers to the match contained in the first parenthesis, \2 in the second parenthesis, and so on. For example, the following pattern finds all fruits that have a repeated pair of letters:
str_view(fruit, "(.)\\1")
# The first way to use a capturing group is to refer back to it within a match with back reference: \1 refers to the match contained in the first parenthesis, \2 in the second parenthesis, and so on. For example, the following pattern finds all fruits that have a repeated pair of letters:
str_view(fruit, "(..)\\1")
# And this one finds all words that start and end with the same pair of letters:
str_view(words, "^(..).*\\1$")
str_view(words, "^(.).*\\1$")
str_view(words, "^(.).*\\1$")
str_view(words, "(..)\\1")
str_view(words, "(..)*\\1")
str_view(words, "(..)*\\1")
str_view(words, "(..)")
str_view(words, "(..)\\1")
str_view(words, "?(..)\\1")
str_view(words, "(..)*(..)\\1")
str_view(words, "(..)*(..)\\2")
str_view(words, "(..)*(..)")
str_view(words, "(..)*(..)\\1")
str_view(words, "(..).*\\1")
str_view(words, "(..).*\\1")
str_view(words, "(.).*\\1.*\\1")
# You can also use back references in str_replace(). For example, this code switches the order of the second and third words in sentences:
sentences |>
str_replace("(\\w+)(\\w+) (\\w+)","\\1 \\3 \\2" |>
str_view())
# You can also use back references in str_replace(). For example, this code switches the order of the second and third words in sentences:
sentences |>
str_replace("(\\w+)(\\w+)(\\w+)","\\1 \\3 \\2") |>
str_view())
# You can also use back references in str_replace(). For example, this code switches the order of the second and third words in sentences:
sentences |>
str_replace("(\\w+)(\\w+)(\\w+)","\\1 \\3 \\2") |>
str_view()
sentences |>
str_replace("(\\w+)(\\w+)(\\w+)","\\1 \\3 \\2") |>
str_view()
# You can also use back references in str_replace(). For example, this code switches the order of the second and third words in sentences:
sentences |>
str_replace("(\\w+) (\\w+) (\\w+)","\\1 \\3 \\2") |>
str_view()
# If you want to extract the matches for each group you can use str_match(). But str_match() returns a matrix, so it’s not particularly easy to work with8:
sentences |>
str_match("the (\\w+) (\\w+)") |>
head()
# You could convert to a tibble and name the columns:
sentences |>
str_match("the (\\w+) (\\w+)") |>
as_tibble() |>
set_names(c("match", "word1", "word2")) |>
head()
library(purrr)
sentences |>
str_match("the (\\w+) (\\w+)") |>
as_tibble() |>
set_names(c("match", "word1", "word2")) |>
head()
# You could convert to a tibble and name the columns:
sentences |>
str_match("the (\\w+) (\\w+)") |>
as_tibble(.name_repair = "minimal") |>
set_names(c("match", "word1", "word2")) |>
head()
sentences |>
str_match("the (\\w+) (\\w+)") |>
head()
# You could convert to a tibble and name the columns:
sentences |>
str_match("the (\\w+) (\\w+)") |>
as_tibble(.name_repair = "minimal") |>
set_names(c("match", "word1", "word2"))
# Occasionally, you’ll want to use parentheses without creating matching groups. You can create a non-capturing group with (?:)
x <- c("a gray cat", "a grey dog")
str_match(x, "gr(e|a)y")
str_match(x, "gr(?:e|a)y")
# How would you match the literal string "'\?
str_view(c("a", "a'", "a''", "a'''"), "'\\'")
# How would you match the literal string "'\?
str_view(c("a", "a'", "a'", "a'''", "Rashad"), "'\\'")
# How would you match the literal string "'\?
str_view(c("a", "a'", "a'", "a'''", "Rashad'\\"), "'\\'")
# How would you match the literal string "'\?
str_view(c("a", "a'", "a'", "a'''", "Rashad'\\"), "'\\")
# How would you match the literal string "'\?
str_view(c("a", "a'", "a'", "a'''", "Rashad'\\"), "\\'")
str_view(c("a", "a'", "a'", "a'''", "Rashad'\\"), "\\'")
# How would you match the literal string "'\?
str_view(c("a", "a'", "a'", "a'''", "Rashad'\\"), "'\\\\'")
str_view(c("a", "a'", "a'", "a'''", "Rashad'\\"), "'\\\\'")
# How would you match the literal string "'\?
str_view(c("a", "a'", "a'", "a'''", "Rashad'\\"), "'\\\'")
# How would you match the literal string "'\?
str_view(c("a", "a'", "a'", "a'''", "Rashad"), "'\\'")
# Given the corpus of common words in stingr::word, create regular expressions to match words that:
# a. Start with "y"
str_view(words, "^y")
# b. Don't start with "y"
str_view(words, "^[^y]")
# c. End with "x"
str_view(words, "x$")
# d. Are exactly three letters long
str_view(words, {3})
# d. Are exactly three letters long
str_view(words, "\\w")
# d. Are exactly three letters long
str_view(words, "\\w+")
# d. Are exactly three letters long
str_view(words, "^{3}$")
# d. Are exactly three letters long
str_view(words, "^{3}$")
str_view(words, "^{3}$")
str_view(words, "^...$")
# d. Are exactly three letters long
str_view(words, "^\w{3}$")
# d. Are exactly three letters long
str_view(words, "^\w{3}$")
# d. Are exactly three letters long
str_view(words, "^\\w{3}$")
# e. Have seven letters or more
str_view(words, "^\\w{7,}$")
str_view(words, "^.......*$")
str_view(words, "^.......+$")
# f. Contain a vowel-consonant pair
str_view(words, "[aeiou][^aeiou]")
# g. Contain at least two vowel-consonant pairs in a row.
str_view(words, "[aeiou][^aeiou][aeiou][^aeiou]")
# h. Only consist of repeated vowel-consonant pairs
str_view(words, "^(..)\\1+$")
consanants <- c("b", "c", "d", "f", "g", "h", "j", "k", "l", "m", "n", "p", "q", "r", "s", "t", "v", "w", "x", "y", "z")
vowels <- c("a", "e", "i", "o", "u")
# h. Only consist of repeated vowel-consonant pairs
str_view(words, "^[vowels][consanants]$")
# h. Only consist of repeated vowel-consonant pairs
str_view(words, "^(..)\\1+$")
# h. Only consist of repeated vowel-consonant pairs
str_view(words, "^[aeiou][^aeiou]{2}$")
# h. Only consist of repeated vowel-consonant pairs
str_view(words, "^(?:(?i)[aeiou][^aeiou]){2,}$")
# Create 11 regular expressions that match the British or American spellings for each of the following words:
# airplane/aeroplane
str_view(words, "a(?:ir|er)plane")
str_view(words, "a(?:ir|er)plane")
# Create 11 regular expressions that match the British or American spellings for each of the following words:
# airplane/aeroplane
str_view(words, "^\baer(?:o)?plane\b$")
# Create 11 regular expressions that match the British or American spellings for each of the following words:
# airplane/aeroplane
british_american <- c("airplane", "aeroplane")
str_view(british_american, "^\baer(?:o)?plane\b$")
str_view(british_american, "^\baer(?:o)?plane\b$")
str_view(british_american, "airplane")
str_view(british_american, "aero?plane")
# If you’re trying to match a literal ., $, |, *, +, ?, {, }, (, ), there’s an alternative to using a backslash escape: you can use a character class: [.], [$], [|], ... all match the literal values.
str_view(c("a.b","a$b","a|b"),"[|]")
str_view(british_american, "a(?:ir|ero)plane")
#aluminum/aluminium
british_american <- c("aluminum", "aluminium")
str_view(british_american, "alumin(?:um|ium)")
# analog/analogue
british_american <- c("analog", "analogue")
str_view(british_american, "analog(?:ue)?")
str_view(british_american, "analog(?:ue)")
str_view(british_american, "analog(?:ue)?")
# ass/arse
british_american <- c("ass","arse")
str_view(british_american, "a(?:ss|rse)")
str_view(british_american, "a(?:ss|rse)?")
str_view(british_american, "a(?:ss|rse)")
# center/centre
british_american <- c("center","centre")
str_view(british_american,"cent(?:er|re)")
# Create 11 regular expressions that match the British or American spellings for each of the following words:
british_american <- c("airplane", "aeroplane", "aluminum", "aluminium","analog", "analogue","ass","arse","center","centre","defense","defence","donut","doughnut", "gray","grey", "modeling","modelling","skeptic","sceptic", "summarize","summarise")
# airplane/aeroplane
str_view(british_american, "a(?:ir|ero)plane")
#aluminum/aluminium
str_view(british_american, "alumin(?:um|ium)")
# analog/analogue
str_view(british_american, "analog(?:ue)?")
# ass/arse
str_view(british_american, "a(?:ss|rse)")
# center/centre
str_view(british_american,"cent(?:er|re)")
# defense/defence
str_view(british_american,"defen(?:se|ce)")
# defense/defence
str_view(british_american,"defen(?:se|ce)")
# donut/doughnut
str_view(british_american, "do(?:ugh|)nut")
# donut/doughnut
str_view(british_american, "do(?:ugh)nut")
# donut/doughnut
str_view(british_american, "do(?:ugh|)nut")
# gray/grey
str_view(british_american,"gr(?:a|e)y")
# modeling/modelling
str_view(british_american,"model(?:l\)ing")
# modeling/modelling
str_view(british_american,"model(?:l|)ing")
# skeptic/sceptic
str_view(british_american, "s(?:k|c)eptic")
# summarize/summarise
str_view(british_american,"summari(?:se|ze")
# summarize/summarise
str_view(british_american,"summari(?:se|ze)")
# Switch the first and last letters in words. Which of those strings are still words?
words |>
str_replace("(^) ($)", "//2 //1") |>
str_view()
words |>
str_replace("(^) ($)", "//2 //1") |>
str_view()
# Switch the first and last letters in words. Which of those strings are still words?
words |>
str_replace("(^) ($)", "//1 //2") |>
str_view()
words |>
str_replace("(^) ($)", "//1 //2") |>
str_view()
# Switch the first and last letters in words. Which of those strings are still words?
words |>
paste(tail(word, 1), substring(word, 2, nchar(word) - 1), head(word, 1), sep = "") |>
str_view()
# Switch the first and last letters in words. Which of those strings are still words?
words |>
paste(tail(word, 1), substring(word, 2, nchar(word) - 1), head(word, 1), sep = "")
# Switch the first and last letters in words. Which of those strings are still words?
paste(tail(words, 1), substring(words, 2, nchar(words) - 1), head(words, 1), sep = "")
# Switch the first and last letters in words. Which of those strings are still words?
paste(tail(words, 1), substring(words, 2, nchar(words) - 1), head(words, 1), sep = " ")
# Switch the first and last letters in words. Which of those strings are still words?
paste(tail(words, 1), head(words, 1), sep = " ")
# Switch the first and last letters in words. Which of those strings are still words?
str_view(words,"(?<= )(\w)([^ ]+)(?=\w)(?: )(?!\1)(\w)([^ ]+)(\1)")
# Switch the first and last letters in words. Which of those strings are still words?
str_view(words,"(?<= )(\\w)([^ ]+)(?=\\w)(?: )(?!\\1)(\\w)([^ ]+)(\\1)")
str_view(words,"(?<= )(\\w)([^ ]+)(?=\\w)(?: )(?!\\1)(\\w)([^ ]+)(\\1)")
# Switch the first and last letters in words. Which of those strings are still words?
words |>
str_replace("([a-zA-Z])(.*)([a-zA-Z])","\\3\\2\\1") |>
head(25)
# Describe, in words, what these expressions will match:
# (.)\1\1
str_view(words,"(.)\1\1")
str_view(words,"(.)\1\1")
# "(.)(.)\\2\\1"
str_view(words,"(.)(.)\\2\\1")
# "(.)(.)\\2\\1"
str_view(words,"(.)(.)\\1\\2")
# "(.)(.)\\2\\1"
str_view(words,"(.)(.)\\2\\1")
# Describe, in words, what these expressions will match:
# (.)\1\1
str_view(words,"(.)\1\1")
# "(.)(.)\\2\\1"
str_view(words,"(.)(.)\\2\\1")
# (..)\1
str_view(words,"(..)\1")
# (..)\1
str_view(words,"(..)\1")
# "(.).\\1.\\1"
str_view(words,"(.).\\1.\\1")
# "(.)(.)(.).*\\3\\2\\1"
str_view(words,"(.)(.)(.).*\\3\\2\\1")
str_view(words, "(.)\\1\\1")
str_view(words, "(.)\\1\\1")
str_view(words, "(.)\1\1")
str_view(words, "^(.).*\\1$")
str_view(words, "(..).*\\1")
str_view(words, "(.).*\\1.*\\1")
foods <- c("bell pepper", "bilberry", "blackberry", "blood orange", "blueberry", "cantaloupe", "chili pepper", "cloudberry", "elderberry", "lime", "lychee", "mulberry", "olive", "salal berry")
foods
foods_formatted <- paste(foods, collapse = ", ")
foods_formatted
str_view(words, "(.)\1\1")
sample_words <- c("aaa","bbb","xyz","bba", "cctv","brrr")
str_view(sample_words, "(.)\1\1")
sample_words <- c("aaa","bbb","xyz","bba", "cctv","brrr")
str_view(sample_words, "(.)\1\1")
sample_words <- c("aaa","bbb","xyz","bba", "cctv","brrr")
str_view(sample_words, "(.)\1\1")
str_view(sample_words, "(.)\\1\\1")
sample_words <- c("aaa","bbb","xyz","bba", "cctv","brrr")
str_view(sample_words, "(.)\\1\\1")
sample_words <- c("aaa","bbb","xyz","bba", "cctv","brrr")
str_view(sample_words, "(.)\\1\\1")
sample_words <- c("aaa","bbb","xyz","bba", "cctv","brrr")
str_view(sample_words, "(.)\\1\\1")
sample_words <- c("aaa","bbb","xyz","bba", "cctv","brrr")
str_view(sample_words, "(.)\\1\\1")
str_view("(.)(.)\\2\\1")
str_view(words,"(.)(.)\\2\\1")
majors_url <- "https://raw.githubusercontent.com/fivethirtyeight/data/master/college-majors/majors-list.csv"
majors <- read.csv(majors_url)
grep(pattern = "DATA|STATISTICS", majors$Major, value = TRUE, ignore.case = TRUE)
foods <- c("bell pepper", "bilberry", "blackberry", "blood orange", "blueberry", "cantaloupe", "chili pepper", "cloudberry", "elderberry", "lime", "lychee", "mulberry", "olive", "salal berry")
foods
foods_formatted <- paste(foods, collapse = ", ")
foods_formatted
sample_words <- c("aaa","bbb","xyz","bba", "cctv","brrr")
str_view(sample_words, "(.)\\1\\1")
str_view(words,"(.)(.)\\2\\1")
# (..)\1
str_view(words,"(..)\1")
str_view(words,"(..)\1")
str_view(words,"(..)\\1")
str_view(words,"(.).\\1.\\1")
str_view(words,"(.)(.)(.).*\\3\\2\\1")
